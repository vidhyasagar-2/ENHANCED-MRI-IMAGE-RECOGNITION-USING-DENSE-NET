clc;
clear;
close all;

%% Define Dataset Paths
mainFolder = fullfile('C:', 'Users', 'rosha', 'OneDrive', 'Documents', 'MATLAB', 'MyDataset');
normalDir = fullfile(mainFolder, 'Normal');
strokeDir = fullfile(mainFolder, 'Stroke');

if ~isfolder(normalDir) || ~isfolder(strokeDir)
    error('One or more dataset folders not found.');
end

%% Load Image Datastore
trainImagesDS = imageDatastore({normalDir, strokeDir}, 'IncludeSubfolders', true, 'LabelSource', 'foldernames');
fprintf('Total images found: %d\n', numel(trainImagesDS.Files));

%% Create Synthetic Masks
maskDir = fullfile(mainFolder, 'GeneratedMasks');
if ~isfolder(maskDir), mkdir(maskDir); end

for i = 1:numel(trainImagesDS.Files)
    img = readimage(trainImagesDS, i);
    if size(img, 3) == 1
        img = cat(3, img, img, img);
    end
    
    mask = zeros(size(img, 1), size(img, 2), 'uint8');
    if contains(trainImagesDS.Files{i}, 'Stroke')
        mask(50:end-50, 50:end-50) = 255;
    end
    
    imwrite(mask, fullfile(maskDir, sprintf('mask_%d.png', i)));
end
fprintf('Synthetic masks generated.\n');

%% Resize and Normalize Images & Masks
imageSize = [256 256 3];
maskSize = [256 256];

processedImageDir = fullfile(mainFolder, 'ProcessedImages');
processedMaskDir = fullfile(mainFolder, 'ProcessedMasks');

if ~isfolder(processedImageDir), mkdir(processedImageDir); end
if ~isfolder(processedMaskDir), mkdir(processedMaskDir); end

for i = 1:numel(trainImagesDS.Files)
    img = readimage(trainImagesDS, i);
    mask = imread(fullfile(maskDir, sprintf('mask_%d.png', i)));
    
    if size(img, 3) == 1
        img = cat(3, img, img, img);
    end
    
    img = imresize(img, imageSize(1:2));
    mask = imresize(mask, maskSize, 'nearest');
    
    mask = uint8(mask > 127) * 255;
    
    imwrite(img, fullfile(processedImageDir, sprintf('image_%d.jpg', i)));
    imwrite(mask, fullfile(processedMaskDir, sprintf('mask_%d.png', i)));
end
fprintf('Processed images and masks saved.\n');

%% Load Processed Datastore
trainImagesDSProcessed = imageDatastore(processedImageDir, 'IncludeSubfolders', true);
classNames = ["background", "tumor"];
pixelLabels = [0, 255];
trainMasksDSProcessed = pixelLabelDatastore(processedMaskDir, classNames, pixelLabels);

if numel(trainImagesDSProcessed.Files) ~= numel(trainMasksDSProcessed.Files)
    error('Mismatch between processed images and masks.');
end

%% Data Augmentation
augmenter = imageDataAugmenter('RandRotation', [-10, 10], ...
                               'RandXReflection', true, ...
                               'RandYReflection', true, ...
                               'RandXScale', [0.9, 1.1], ...
                               'RandYScale', [0.9, 1.1]);

trainDataStore = pixelLabelImageDatastore(trainImagesDSProcessed, trainMasksDSProcessed, 'DataAugmentation', augmenter);

%% Define CNN Network Architecture
layers = [
    imageInputLayer(imageSize, 'Normalization', 'none')
    convolution2dLayer(3, 64, 'Padding', 'same')
    batchNormalizationLayer
    reluLayer
    maxPooling2dLayer(2, 'Stride', 2)

    convolution2dLayer(3, 128, 'Padding', 'same')
    batchNormalizationLayer
    reluLayer
    maxPooling2dLayer(2, 'Stride', 2)

    convolution2dLayer(3, 256, 'Padding', 'same')
    batchNormalizationLayer
    reluLayer
    maxPooling2dLayer(2, 'Stride', 2)

    transposedConv2dLayer(4, 256, 'Stride', 2, 'Cropping', 'same')
    batchNormalizationLayer
    reluLayer

    transposedConv2dLayer(4, 128, 'Stride', 2, 'Cropping', 'same')
    batchNormalizationLayer
    reluLayer

    transposedConv2dLayer(4, 64, 'Stride', 2, 'Cropping', 'same')
    batchNormalizationLayer
    reluLayer

    convolution2dLayer(1, 2, 'Padding', 'same') 
    softmaxLayer 
    pixelClassificationLayer
];

%% Define Training Options (Optimized for Speed)
options = trainingOptions('adam', ...
    'MiniBatchSize', 16, ...
    'MaxEpochs', 5, ...  % Reduced from 10 to 5
    'InitialLearnRate', 1e-4, ... % Decreased learning rate for stability
    'LearnRateSchedule', 'piecewise', ...
    'LearnRateDropFactor', 0.5, ...
    'Verbose', true, ...
    'Plots', 'training-progress', ...
    'Shuffle', 'every-epoch', ...
    'ValidationData', trainDataStore, ...
    'ValidationFrequency', 10, ...
    'ValidationPatience', 3);

%% Train the Model
net = trainNetwork(trainDataStore, layers, options);
save('trainedCNNModel.mat', 'net');

disp('Training Completed Successfully!');

%% Manually Select an Image for Hemorrhage Detection
[filename, pathname] = uigetfile({'.jpg;.png', 'Image Files (*.jpg, *.png)'}, 'Select an Image for Hemorrhage Detection');
if isequal(filename, 0)
    disp('No image selected.');
else
    selectedImg = imread(fullfile(pathname, filename));
    
    % Ensure image has 3 channels
    if size(selectedImg, 3) == 1
        selectedImg = cat(3, selectedImg, selectedImg, selectedImg);
    end
    
    % Perform segmentation
    predictedMask = semanticseg(selectedImg, net);
    
    % Resize the predicted mask to match the selected image size
    predictedMask = imresize(predictedMask, [size(selectedImg, 1), size(selectedImg, 2)], 'nearest');
    
    % Convert categorical mask to numeric format for display
    predictedMask = uint8(predictedMask == "tumor") * 255;

    % Display the selected image and its segmentation result
    highlightedImg = labeloverlay(selectedImg, predictedMask, 'Transparency', 0.5);
    
    figure;
    subplot(1, 3, 1); imshow(selectedImg); title('Original Image');
    subplot(1, 3, 2); imshow(predictedMask, []); title('Predicted Mask');
    subplot(1, 3, 3); imshow(highlightedImg); title('Highlighted Tumor/Hemorrhage');

    disp('Segmentation Results Displayed.');
end
